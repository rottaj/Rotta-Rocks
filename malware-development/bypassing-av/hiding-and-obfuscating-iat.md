---
description: >-
  The Import Address Table (IAT) contains information regarding a PE file, such
  as the functions used and the DLLs exporting them. This type of information
  can be used to signature and detect the binary
---

# Hiding & Obfuscating IAT

***

## Dynamic Load at Runtime

It's possible to use `GetProcAddress`, `GetModuleHandle`, and `LoadLibrary` to dynamically load WINAPI functions at runtime.&#x20;

```c
typedef LPVOID (WINAPI* fnVirtualAllocEx)(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);

//...
fnVirtualAllocEx pVirtualAllocEx = GetProcAddress(GetModuleHandleA("KERNEL32.DLL"), "VirtualAllocEx");
pVirtualAllocEx(...);
```

_<mark style="color:red;">**NOTE:**</mark>_ This is not a very good solution as these functions will appear in the IAT, which by itself is signatured.&#x20;

## Creating Custom WinAPI Functions

For a better overview view:

{% embed url="https://app.gitbook.com/o/KN1jS9mFcRAy3dgznyeV/s/Ntkym7wd1H5AXS7YaAHH/~/changes/73/malware-development/bypassing-av/custom-winapi-functions" %}
Custom WINAPI Functions
{% endembed %}

### Custom GetProcAddress

The `GetProcAddress` WinAPI retrieves the address of an exported function from a specified module handle. The function returns NULL if the function name is not in the specified module handle.

#### How it works

```c
FARPROC GetProcAddress(
  [in] HMODULE hModule,
  [in] LPCSTR  lpProcName
);
```

* `hModule` Base address of the loaded DLL. This is the address where the DLL module is found in the address space of the process.
* `lpcProcName` Retrieving a function's address is found by looping through the exported functions inside the provided DLL and checking if the target function's name exists.

#### Export Table Structure

```c
typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Name;
    DWORD   Base;
    DWORD   NumberOfFunctions;
    DWORD   NumberOfNames;
    DWORD   AddressOfFunctions;     // RVA from base of image
    DWORD   AddressOfNames;         // RVA from base of image
    DWORD   AddressOfNameOrdinals;  // RVA from base of image
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;
```

The relevant members of this structure for this module are the last three.

* `AddressOfFunctions` - Specifies the address of an array of addresses of the exported functions.
* `AddressOfNames` - Specifies the address of an array of addresses of the names of the exported functions.
* `AddressOfNameOrdinals` - Specifies the address of an array of _ordinal numbers_ for the exported functions.

#### Accessing Exported Functions

```c
for (DWORD i = 0; i < pImgExportDir->NumberOfFunctions; i++){
  // Searching for the target exported function 
}
```

### GetProcAddress Code

```c
#include <stdio.h>
#include <wchar.h>
#include <windows.h>


#define TARGET_LIBRARY L"ntdll.dll"
#define TARGET_FUNCTION "NtAllocateVirtualMemory"

int wmain() {

    HMODULE hModule = NULL;
    hModule = LoadLibraryW(TARGET_LIBRARY);
    if (hModule == NULL) {
        wprintf(L"LoadLibrary Failed with Error Code: %d\n", GetLastError());
        return -1;
    }

    // IMPORTANT - Must cast handle address to PBYTE or header parsing will fail
    PBYTE pBase = (PBYTE)hModule;

    wprintf(L"Loaded %s at address: %p\n", TARGET_LIBRARY, pBase);
    PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase;
    if(pImgDosHdr->e_magic != IMAGE_DOS_SIGNATURE) {
        wprintf(L"Failed to Get DOS Header");
        return -1;
    }
    PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr->e_lfanew);
    if (pImgNtHdrs->Signature != IMAGE_NT_SIGNATURE) {
        wprintf(L"Failed to Get NT Header");
        return -1;
    }

    IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs->OptionalHeader;
    if (ImgOptHdr.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC) {
        wprintf(L"Failed to Get Optional Header");
        return -1;
    }

    PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
    // Getting the function's names array pointer
    PDWORD FunctionNameArray 	= (PDWORD)(pBase + pImgExportDir->AddressOfNames);

    // Getting the function's addresses array pointer
    PDWORD FunctionAddressArray 	= (PDWORD)(pBase + pImgExportDir->AddressOfFunctions);

    // Getting the function's ordinal array pointer
    PWORD  FunctionOrdinalArray 	= (PWORD)(pBase + pImgExportDir->AddressOfNameOrdinals);

    for (DWORD i = 0; i < pImgExportDir->NumberOfFunctions; i++){
        // Getting the name of the function
        CHAR* pFunctionName		= (CHAR*)(pBase + FunctionNameArray[i]);
        // Getting the address of the function
        PVOID pFunctionAddress	= (PVOID)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]);
        // Getting the ordinal of the function
        WORD wFunctionOrdinal = FunctionOrdinalArray[i];
        
        if (strcmp((LPCSTR)TARGET_FUNCTION, pFunctionName) == 0) {
            // Return function address
            return pFunctionAddress;
        }
    }

    return 0;
}
```
